---
title: Towards package signing -- who maintains package X?
author: hannes
tags: package signing, security, conex, overview
abstract: We introduce Conex, the package signing system for opam.  We also describe why manual gathering of metadata is out of date, and version control systems are awesome.
---

## Conex

Our goal is to improve the security of [opam](https://opam.ocaml.org),
the OCaml package manager.  We designed and implemented
[Conex](https://github.com/hannesm/conex) ([OCaml Workshop
paper](https://github.com/hannesm/conex-paper/raw/master/paper.pdf), based on
[The Update Framework](https://theupdateframework.github.io/)), which allows
package authors to digitally sign their releases, and clients verify the
downloaded metadata and tarballs.  Conex also prevents other attacks, such as
mix-and-match of released package version, rollback attacks, read the paper for
details or wait for a followup post here :).  Conex also works for private opam
repositories, and does not depend on git nor GitHub.

The implementation is not yet deployed nor released, but we're working hard to
get to this point.  Our goal was from the beginning to get it deployed, and have
a sensible trust model: trust should be in the authors of packages, not in the
repository server, and there is now centralised trust authority (as in X.509).
Watching the main opam repository for a while indicated that some people are
fixing up reverse dependencies, OCaml compiler constraints, build failures (by
adding patches), etc.  We refer to them as janitors, who keep the repository in
tact.  We rely on them, but their life will become a bit more complicated: a
quorum of janitors need to approve unauthorised changes.

Putting things together: conex adds some public keys into the repository, and
opam2 ships a set of fingerprints of the janitors (for bootstrapping).  Each
public key has an identifier connected (e.g. GitHub username), and they share
their namespace with teams, which contains a set of (non-team) users.  One team
are the `janitors`, and if a quorum of them approve a change to a resource, this
change is authenticated.  The team `janitors` is a resource, and thus can be
modified via the same means.  If something fatal happens (a compromise of conex,
e.g. leaking the private keys of a quorum of janitors), we need to generate new
keys and distribute the new fingerprint in an authenticated way (e.g. GPG-signed
mail).

Janitors control two resources we have: users and package names.  For each
package, there is a set of users authorised to modify it.  Modifications include
drafting a new release, adding patches, fixing dependencies.  Modifications to
users and changes to the authorised sets of any package have to be approved by a
quorum of janitors.

### Signing workflow

Once an user is authorised for a package, the workflow is to build the release,
then run a `conex_sign` utility (not yet released, we try to integrate this also
with existing release managing tools), and then open a PR, to be merged once the
CI is happy.  Signing a release is straightforward: compute a checksum of all
participating files (everything in `foo/foo.1`) into a `checksums` file, add an
entry to the `releases` file, and add their hashes in a (per-user) index file,
which is then digitally signed using the private key on the computer.

Publishing a new package needs interaction with the janitors, they need to
authorise that the selected package name is a good name for the package (and not
too general/confusing etc.).  The workflow is slightly adapted: a quorum of
janitors needs to cryptograpically sign this authorisation (instead of a single
clicks on the merge button).

These signing metadata files (keys, teams, authorisations, releases, checksums,
index) are part of the opam repository.  They have been carefully split to
integrate with the git workflow, and avoid merges (since no digital signature
will remain valid after a merge).  Adding the signing metadata to the repository
also avoids an attacker cutting the connection to the signing metadata, while
updating the opam repository.  Compromises of user keys will happen (and keys
may get lost): its damage is contained to the authorised packages.  Janitors and
other users are continuously watching the opam repository, and will hopefully
detect weird PRs to packages and revoke the offending key.

### Verification workflow

Back to the client, they have a set of janitor fingerprints, and download a
repository.  Now they first verify that the janitor team is backed by a quorum
of the janitor fingerprints they have.  If this is not the case, we need a fresh
set of fingerprints.  Once trust in the janitors is established, all keys and
authorisations are verified, as well as the other signing metadata.  The only
asymmetric signatures are on the index files (one per user, 340 atm), the rest
are SHA256 digests which should be reasonably fast.  On subsequent updates of
the repository, only the modified packages need to be verified (conex input is
the patch of the update - it does not rely on git).  Opam2 has support for a
`validation_hook`, which you can configure to call out to `conex_verify` (not
yet released).

### Freshness

Guaranteeing freshness is not trivial: each signature contains a (signed)
timestamp when it was created, but unless we enforce each janitor and author to
sign every x time units, we cannot guarantee that the given repository is not
outdated.  To partially circumvent this problem, there is an (a set of?)
automated service(s) which verify all signatures and checksums periodically and
cryptographically sign the global repository state.  To be implemented as a
MirageOS unikernel.

## Infering maintainers

The most important data for conex is who is authorised for a given package.  We
could have tried to manually write this down, or force each author to create a
pull request for their packages, but this would be a long process and not
smooth: The main opam repository has around 1500 unique packages, and 350
contributors.  Fortunately, it is a git repository with 5 years of history, and
over 6700 pull requests.  Each opam file may also contain a `maintainers` entry,
a list of strings (usually a mail address).

The data sources we correlate are the `maintainers` entry in opam file, and who
actually committed in the opam repository.  This is inspired by [some GitHub
discussion](https://github.com/ocaml/opam/issues/2693).

### GitHub id and email address

For simplicity, since conex uses any (unique) identifier for users, and the opam
repository is hosted on GitHub, we use a GitHub id as user identifier.
Maintainer information is an email address, thus we need a mapping between them.

We wrote a [shell
script](https://raw.githubusercontent.com/hannesm/conex/master/analysis/loop-prs.sh)
to find all PR merges, their GitHub id (in a brittle way: using the name of the
git remote), and email address of the last commit.  It also saves a diff of the
PR for later.  This results in 6703 PRs.

The metadata output is processed by
[github_mail](https://github.com/hannesm/conex/blob/3e1fd0f5f94c7e86fca2b73cab4bf914b0b41808/analysis/maintainer.ml#L128-L150):
we ignore PRs from GitHub organisations `PR.ignore_github`, where commits
`PR.ignore_pr` are picked from a different user (manually), bad mail addresses,
and Jeremy's mail address (it is added to too many GitHub ids otherwise).  The
goal is to have a for an email address a single GitHub id.  318 users are mapped
(opam repo df2890fa7671ba7baf65fb85897d9c87b34a7d3b), with 404 mail addresses.

### Maintainer in opam

As mentioned, lots of packages contain a `maintainers` entry.  In
[`maintainers`](https://github.com/hannesm/conex/blob/3e1fd0f5f94c7e86fca2b73cab4bf914b0b41808/analysis/maintainer.ml#L40-L65)
we extract the mail addresses of the [most recently released opam
file](https://github.com/hannesm/conex/blob/3e1fd0f5f94c7e86fca2b73cab4bf914b0b41808/analysis/maintainer.ml#L70-L86).
Some hardcoded matches are teams which do not properly maintain the maintainers
field (such as mirage and xapi-project ;).  We're open for suggestions to extend
this massaging to the needs.  Additionally, the contact at ocamlpro mail address
was used for all packages before the maintainers entry was introduced (based on
a discussion with Louis Gesbert).  Resulting in 1360 packages containing email
addresses, 105 not.

### Fitness

Combining these two data sources, we hoped to find a strict small set of whom to
authorise for which package.  Turns out some people use different mail addresses
for git commits and opam maintainer entries, which [are be easily
fixed](https://github.com/hannesm/conex/blob/3e1fd0f5f94c7e86fca2b73cab4bf914b0b41808/analysis/maintainer.ml#L230-L266).

While [processing the full diffs of each
PR](https://github.com/hannesm/conex/blob/3e1fd0f5f94c7e86fca2b73cab4bf914b0b41808/analysis/maintainer.ml#L163-L202)
(using the diff parser of conex mentioned above), ignoring the 44% done by
[janitors](https://github.com/hannesm/conex/blob/3e1fd0f5f94c7e86fca2b73cab4bf914b0b41808/analysis/maintainer.ml#L152-L159)
(a manually created set by looking at log data, please report if wrong), we
categorise the modifications: authorised modification (the GitHub id is
authorised for the package), modification by an user to a team-owned package
(propose to add this user to the team), modification of a package where no
GitHub id is authorised, and unauthorised modification.  We also ignore packages
which are no longer in the opam repository.

3219 modifications were authorised, 653 were team-owned, 468 were to packages
with no maintainer, and 834 unauthorised.

Out of the 468 modifications to packages with no maintainer, 68 are a global
one-to-one user to package relation, and could be directly authorised.

The infered teams are (a slight overapproximation, but the janitors are missing):

```
alt-ergo -> OCamlPro-Iguernlala UnixJunkie backtracking bobot nobrowser
janestreet -> backtracking hannesm j0sh rgrinberg smondet
mirage -> MagnusS dbuenzli djs55 hannesm hnrgrgr jonludlam mato mor1 pgj pqwy pw374 rdicosmo rgrinberg ruhatch sg2342 talex5 yomimono
ocsigen -> balat benozol dbuenzli hhugo hnrgrgr jpdeplaix mfp pveber scjung slegrand45 smondet vasilisp
xapi-project -> dbuenzli djs55 euanh mcclurmc rdicosmo simonjbeaumont yomimono
```

### Conclusion

Manually maintained metadata is easily out of date, and not very useful.  But
combining automatically created metadata with manually, and some manual tweaking
leads to reasonable data.

You can do me a favour by looking through [this opam-repository
branch](https://github.com/hannesm/opam-repository/tree/authorised) and check a)
your GitHub id entry below `keys` subdirectory and b) the `authorisation` file
of your packages (`packages/your-package/authorisation`) and report any
inconsistencies.  Each step mentioned above is a single commit, esp with the
packages [without a
maintainer](https://github.com/hannesm/opam-repository/commit/e3d57d30f97251334f649f53a4aa25a09a0a2817).

The [full output data](https://berlin.ccc.de/~hannes/20170110conex.txt) of a run is available.

Please report any issues via the [conex issue tracker](https://github.com/hannesm/conex/issues).
