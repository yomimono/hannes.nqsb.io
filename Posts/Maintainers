---
title: Towards package signing -- who maintains package X?
author: hannes
tags: package signing, security, conex, overview
abstract: We introduce Conex, the package signing system for opam.  We also describe why manual gathering of metadata is out of date, and version control systems are awesome.
---

## Conex

Our goal is to improve the security of [opam](https://opam.ocaml.org),
the OCaml package manager.  We designed and implemented
[Conex](https://github.com/hannesm/conex) ([OCaml Workshop
paper](https://github.com/hannesm/conex-paper/raw/master/paper.pdf), based on
[The Update Framework](https://theupdateframework.github.io/)), which allows
package authors to digitally sign their releases, and clients to verify the
downloaded metadata and tarballs.  Conex also prevents other attacks, such as
mix-and-match of released package version, and rollback attacks -- read the paper for
details or wait for a followup post here :)  Conex also works for private opam
repositories, and does not depend on git or GitHub.

The implementation is not yet deployed nor released, but we're working hard to
get to that point.  Our goal from the beginning was to get it deployed, with a
sensible security model: package authors sign their releases, and clients verify
that the tarball, dependencies, and build instructions are signed by the
authors.  A team of janitors, which nowadays already fixes dependency
constraints, add patches, ..., will also maintain authorisations: who is
responsible for each package.  To improve the security, a single janitor cannot
approve a change, instead a quorum (m out of n) of janitor signatures are
required.

Putting things together: conex adds public keys into the repository, and opam2
ships a set of fingerprints of the janitors (for bootstrapping).  GitHub ids
will be used as identifiers, and each author may have a public key stored in the
repository.  A set of authors can form a team, and is itself an identifier
(without any key material), which can be used for authorising packages.  Teams
are also stored in the opam repository (and are signed), and authors can join
and leave teams (teams are not allowed inside of teams!), which needs to be
approved by (a quorum of the members of) the team `janitors`.  For each public
key a list of approved resources (package release, team, publickey,
authorisation - in the form type, version, digest) is stored in an `index` file,
modified solely by the person holding the private key (avoiding merge conflicts
between persons), and digitally signed.

If the private key of an author is stolen, the thieve can release new packages
in the name of the author, which will likely be detected (by people watching the
opam-repository, etc.), and janitors can revoke the key (and help the author to
establish a new key).  When conex is compromised, e.g. a quorum of janitor
private keys are leaked, a set of janitors can generate new keys, and distribute
the new fingerprints over an authenticated channel (e.g. GPG-signed mail, new
opam package).

Janitors control the two resources we have: identifiers (authors and teams), and
package names.  For each package, there is a set of identifiers authorised to
modify it.  Modifications include drafting a new release, adding patches, fixing
dependencies.  Modifications to authors, teams, and changes to the authorised
sets of any package have to be approved by a quorum of janitors.

### Signing workflow

Once an author is authorised for a package, the workflow is to build the
release, then run a `conex_author sign` utility (not yet released, we try to
integrate this also with existing release management tools), and then open a PR,
to be merged once the CI is happy.  Signing a release is straightforward:
compute a checksum of all participating files (everything in `foo/foo.1`) into a
`checksums` file (package-local), add an entry to the `releases` file
(package-global), and add their hashes into your index file, which is then
digitally signed with your private key.

At the moment, publishing a new package already needs interaction with the
janitors, who keep the repository in shape: the package name is not taken yet,
and not too general, etc.  A new release of an already existing package is
usually done by an author.  If a random stranger releases a well-known package,
janitors will ensure that it is an intended release.

The workflow for janitors needs some slight modifications: instead of pressing
the green merge button, digital signatures are needed (of multiple janitors,
each in their own index file).  Once a quorum of janitors approve a change, the
PR is merged.

These signing metadata files (`keys`, `teams`, `authorisations`, `releases`, `checksums`,
`index`) are part of the opam repository.  They have been carefully split to
integrate with the git workflow, and avoid merges (since no digital signature
will remain valid after a merge).  Adding the signing metadata to the repository
also avoids an attacker cutting the connection to the signing metadata, while
updating the opam repository.

### Verification workflow

Back to the client! They have a set of janitor fingerprints, and download a
repository.  They first verify that the janitor team is backed by a quorum
of the janitor fingerprints they have.  If this is not the case, they need a fresh
set of fingerprints (via another trusted channel, HTTPS, opam release, ...).  Once trust in the janitors is established, all keys and
authorisations are verified, as well as the other signing metadata.  The only
asymmetric signatures are on the index files (one per author, giving 340 currently), the rest
are SHA256 digests which should be reasonably fast.  On subsequent updates of
the repository, only the modified packages need to be verified (conex input is
the patch of the update - it does not rely on git).  Opam2 has support for a
`validation_hook`, which you can configure to call out to `conex_verify` (not
yet released).

### Freshness

Guaranteeing freshness is not trivial: each signature contains a (signed)
timestamp when it was created, but unless we enforce each janitor and author to
sign every x time units, we cannot guarantee that the given repository is not
outdated.  To partially circumvent this problem, there is an (a set of?)
automated service(s) which verify all signatures and checksums periodically and
cryptographically sign the global repository state.  To be implemented as a
MirageOS unikernel.

## Inferring maintainers

The most important data for conex is who is authorised for a given package.  We
could have tried to manually write this down, or to force each author to create a
pull request for their packages, but this would be a long process and not
easy: the main opam repository has around 1500 unique packages, and 350
contributors.  Fortunately, it is a git repository with 5 years of history, and
over 6700 pull requests.  Each opam file may also contain a `maintainers` entry,
a list of strings (usually a mail address).

The data sources we correlate are the `maintainers` entry in opam file, and who
actually committed in the opam repository.  This is inspired by [some GitHub
discussion](https://github.com/ocaml/opam/issues/2693).

### GitHub id and email address

For simplicity, since conex uses any (unique) identifier for authors, and the opam
repository is hosted on GitHub, we use a GitHub id as author identifier.
Maintainer information is an email address, thus we need a mapping between them.

We wrote a [shell
script](https://raw.githubusercontent.com/hannesm/conex/master/analysis/loop-prs.sh)
to find all PR merges, their GitHub id (in a brittle way: using the name of the
git remote), and email address of the last commit.  It also saves a diff of the
PR for later.  This results in 6703 PRs.

The metadata output is processed by
[github_mail](https://github.com/hannesm/conex/blob/3e1fd0f5f94c7e86fca2b73cab4bf914b0b41808/analysis/maintainer.ml#L128-L150):
we ignore PRs from GitHub organisations `PR.ignore_github`, where commits
`PR.ignore_pr` are picked from a different author (manually), bad mail addresses,
and [Jeremy's](https://github.com/yallop) mail address (it is added to too many GitHub ids otherwise).  The
goal is to have a for an email address a single GitHub id.  318 authors are mapped
(opam repo df2890fa7671ba7baf65fb85897d9c87b34a7d3b), with 404 mail addresses.

### Maintainer in opam

As mentioned, lots of packages contain a `maintainers` entry.  In
[`maintainers`](https://github.com/hannesm/conex/blob/3e1fd0f5f94c7e86fca2b73cab4bf914b0b41808/analysis/maintainer.ml#L40-L65)
we extract the mail addresses of the [most recently released opam
file](https://github.com/hannesm/conex/blob/3e1fd0f5f94c7e86fca2b73cab4bf914b0b41808/analysis/maintainer.ml#L70-L86).
Some hardcoded matches are teams which do not properly maintain the maintainers
field (such as mirage and xapi-project ;).  We're open for suggestions to extend
this massaging to the needs.  Additionally, the contact at ocamlpro mail address
was used for all packages before the maintainers entry was introduced (based on
a discussion with Louis Gesbert).  Resulting in 1360 packages containing email
addresses, 105 not.

### Fitness

Combining these two data sources, we hoped to find a strict small set of whom to
authorise for which package.  Turns out some people use different mail addresses
for git commits and opam maintainer entries, which [are be easily
fixed](https://github.com/hannesm/conex/blob/3e1fd0f5f94c7e86fca2b73cab4bf914b0b41808/analysis/maintainer.ml#L230-L266).

While [processing the full diffs of each
PR](https://github.com/hannesm/conex/blob/3e1fd0f5f94c7e86fca2b73cab4bf914b0b41808/analysis/maintainer.ml#L163-L202)
(using the diff parser of conex mentioned above), ignoring the 44% done by
[janitors](https://github.com/hannesm/conex/blob/3e1fd0f5f94c7e86fca2b73cab4bf914b0b41808/analysis/maintainer.ml#L152-L159)
(a manually created set by looking at log data, please report if wrong), we
categorise the modifications: authorised modification (the GitHub id is
authorised for the package), modification by an author to a team-owned package
(propose to add this author to the team), modification of a package where no
GitHub id is authorised, and unauthorised modification.  We also ignore packages
which are no longer in the opam repository.

3219 modifications were authorised, 653 were team-owned, 468 were to packages
with no maintainer, and 834 unauthorised.

Out of the 468 modifications to packages with no maintainer, 68 are a global
one-to-one author to package relation, and could be directly authorised.

The infered teams are (a slight overapproximation, but the janitors are missing):

```
alt-ergo -> OCamlPro-Iguernlala UnixJunkie backtracking bobot nobrowser
janestreet -> backtracking hannesm j0sh rgrinberg smondet
mirage -> MagnusS dbuenzli djs55 hannesm hnrgrgr jonludlam mato mor1 pgj pqwy pw374 rdicosmo rgrinberg ruhatch sg2342 talex5 yomimono
ocsigen -> balat benozol dbuenzli hhugo hnrgrgr jpdeplaix mfp pveber scjung slegrand45 smondet vasilisp
xapi-project -> dbuenzli djs55 euanh mcclurmc rdicosmo simonjbeaumont yomimono
```


### Alternative approach: GitHub urls

An alternative approach, only for GitHub hosted projects, would be to authorise
[the use of the user part of the GitHub repository
URL](https://github.com/hannesm/conex/blob/github/analysis/maintainer.ml#L37-L91).
Results after filtering GitHub organisations are not yet satisfactory (but only
56 packages with no maintainer, [output
repo](https://github.com/hannesm/opam-repository/tree/github).  This approach
completely ignores the manually written maintainer field.

### Conclusion

Manually maintained metadata is easily out of date, and not very useful.  But
combining automatically created metadata with manually, and some manual tweaking
leads to reasonable data.

You can do me a favour by looking through [this opam-repository
branch](https://github.com/hannesm/opam-repository/tree/authorised) and check a)
your GitHub id entry below `keys` subdirectory and b) the `authorisation` file
of your packages (`packages/your-package/authorisation`) and report any
inconsistencies.  Each step mentioned above is a single commit, esp with the
packages [without a
maintainer](https://github.com/hannesm/opam-repository/commit/e3d57d30f97251334f649f53a4aa25a09a0a2817).

The [full output data](https://berlin.ccc.de/~hannes/20170110conex.txt) of a run is available.

Please report any issues via the [conex issue tracker](https://github.com/hannesm/conex/issues).
